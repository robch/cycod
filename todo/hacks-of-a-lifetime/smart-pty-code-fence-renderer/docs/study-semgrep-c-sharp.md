# Study: semgrep/semgrep-c-sharp

**Repo:** semgrep/semgrep-c-sharp  
**Study Date:** 2025-01-XX  
**Location:** `external/semgrep-c-sharp/`  
**Repo #:** 9 of 29

---

## Executive Summary

**Type:** Auto-generated OCaml bindings for tree-sitter C# grammar  
**Purpose:** Parse C# code into OCaml CST for Semgrep static analysis  
**Generator:** ocaml-tree-sitter (automatic binding generator)  
**Tree-sitter usage:** OCaml FFI wrapper around tree_sitter_c_sharp()  

**Study value:** ‚≠ê 1/10 - Auto-generated bindings, no usage examples, confirms known patterns

**Key finding:** This is another "binding repo without examples" (like Repo 6: zig-tree-sitter). All code is auto-generated by ocaml-tree-sitter. Teaches nothing about tree-sitter usage patterns or design decisions.

**Recommendation:** ‚ùå **No value for our project** - Skip similar auto-generated binding repos in future

---

## What This Repo Is

### Overview

semgrep-c-sharp is a **generated** repository containing OCaml bindings to the tree-sitter C# parser. It's part of Semgrep's multi-language static analysis infrastructure.

**Generation process:**
1. Tree-sitter C# grammar (tree-sitter-c-sharp)
2. Fed through ocaml-tree-sitter generator
3. Produces OCaml FFI bindings + typed CST
4. Used by Semgrep's pattern matcher

**Not a hand-written example** - Everything is auto-generated.

### Repository Structure

```
semgrep-c-sharp/
‚îú‚îÄ‚îÄ bin/
‚îÇ   ‚îî‚îÄ‚îÄ Main.ml              # 12 lines - Simple entry point
‚îú‚îÄ‚îÄ lib/
‚îÇ   ‚îú‚îÄ‚îÄ bindings.c           # 51 lines - OCaml FFI wrapper
‚îÇ   ‚îú‚îÄ‚îÄ parser.c             # 1.4M lines - Generated C# grammar
‚îÇ   ‚îú‚îÄ‚îÄ scanner.c            # 421 lines - External scanner
‚îÇ   ‚îú‚îÄ‚îÄ Parse.ml             # 11K lines - Auto-generated parser wrapper
‚îÇ   ‚îú‚îÄ‚îÄ Parse.mli            # 34 lines - Interface
‚îÇ   ‚îú‚îÄ‚îÄ CST.ml               # 2.4K lines - Auto-generated CST types
‚îÇ   ‚îî‚îÄ‚îÄ Boilerplate.ml       # 4.3K lines - Auto-generated mappers
‚îú‚îÄ‚îÄ config/
‚îÇ   ‚îî‚îÄ‚îÄ discover.ml          # Build configuration
‚îî‚îÄ‚îÄ fyi/
    ‚îú‚îÄ‚îÄ tree-sitter-version  # Tree-sitter version used
    ‚îî‚îÄ‚îÄ versions             # Git commit references
```

**Total:** ~1.5 million lines, 99.9% auto-generated

### What It Does

**Primary function:** Parse C# source code into a typed OCaml CST (Concrete Syntax Tree)

**Usage pattern:**
```ocaml
(* OCaml code using this library *)
let result = Parse.file "Program.cs" in
match result.tree with
| Some cst -> (* Process typed CST *)
| None -> (* Parse failed completely *)
```

**Integration:** Used by Semgrep to analyze C# code for security/correctness patterns

---

## Key Code Examination

### 1. OCaml FFI Bindings (lib/bindings.c)

**The entire wrapper:**
```c
/*
  Generated by ocaml-tree-sitter for c_sharp.
*/

#include <string.h>
#include <tree_sitter/api.h>

#include <caml/alloc.h>
#include <caml/bigarray.h>
#include <caml/callback.h>
#include <caml/custom.h>
#include <caml/memory.h>
#include <caml/mlvalues.h>
#include <caml/threads.h>

// Implemented by parser.c
TSLanguage *tree_sitter_c_sharp();

typedef struct _parser {
  TSParser *parser;
} parser_W;

static void finalize_parser(value v) {
  parser_W *p;
  p = (parser_W *)Data_custom_val(v);
  ts_parser_delete(p->parser);
}

static struct custom_operations parser_custom_ops = {
  .identifier = "parser handling",
  .finalize = finalize_parser,
  .compare = custom_compare_default,
  .hash = custom_hash_default,
  .serialize = custom_serialize_default,
  .deserialize = custom_deserialize_default
};

// OCaml function
CAMLprim value octs_create_parser_c_sharp(value unit) {
  CAMLparam0();
  CAMLlocal1(v);

  parser_W parserWrapper;
  TSParser *parser = ts_parser_new();
  parserWrapper.parser = parser;

  v = caml_alloc_custom(&parser_custom_ops, sizeof(parser_W), 0, 1);
  memcpy(Data_custom_val(v), &parserWrapper, sizeof(parser_W));
  ts_parser_set_language(parser, tree_sitter_c_sharp());
  CAMLreturn(v);
}
```

**What this shows:**
- ‚úÖ Same `ts_parser_new()` + `ts_parser_set_language()` pattern (9th confirmation)
- ‚úÖ Same `tree_sitter_c_sharp()` grammar function signature (9th confirmation)
- ‚úÖ OCaml custom operations for GC integration
- ‚ö†Ô∏è OCaml-specific FFI boilerplate (not relevant to C++)

### 2. Parse Wrapper (lib/Parse.ml - excerpt)

**Parser creation:**
```ocaml
(* Generated by ocaml-tree-sitter. *)

[@@@warning "-42"]
[@@@warning "-26-27-32"]

open Tree_sitter_bindings
open Tree_sitter_run

type mt = Run.matcher_token

external create_parser :
  unit -> Tree_sitter_API.ts_parser = "octs_create_parser_c_sharp"

let parse_source_string ?src_file contents =
  let ts_parser = create_parser () in
  Tree_sitter_parsing.parse_source_string ?src_file ts_parser contents

let parse_source_file src_file =
  let ts_parser = create_parser () in
  Tree_sitter_parsing.parse_source_file ts_parser src_file
```

**What this shows:**
- External FFI call to C bindings
- Wraps tree-sitter parsing in OCaml types
- Auto-generated, no design decisions visible

**The rest of Parse.ml (11K lines):**
- 10,000+ lines of auto-generated node type matchers
- Pattern matching for every C# AST node
- No usage examples, just type mappings

### 3. Entry Point (bin/Main.ml)

**The entire program:**
```ocaml
(* Generated by ocaml-tree-sitter. *)

open Tree_sitter_c_sharp

let () =
  Tree_sitter_run.Main.run
    ~lang:"c_sharp"
    ~parse_source_file:Parse.parse_source_file
    ~parse_input_tree:Parse.parse_input_tree
    ~dump_tree:Boilerplate.dump_tree
    ~dump_extras:Boilerplate.dump_extras
```

**What this shows:**
- Simple CLI for testing parser
- No highlighting, no queries, no ANSI output
- Just parse and dump tree structure

---

## What We Can Learn (Very Little)

### Learning 1: OCaml FFI Pattern (Not Relevant) ‚≠ê

**OCaml custom operations for GC:**
```c
static void finalize_parser(value v) {
  parser_W *p = (parser_W *)Data_custom_val(v);
  ts_parser_delete(p->parser);
}

static struct custom_operations parser_custom_ops = {
  .identifier = "parser handling",
  .finalize = finalize_parser,
  // ... other operations
};
```

**Why this doesn't matter:**
- OCaml-specific GC integration
- We're using C++ (RAII handles cleanup)
- Already know cleanup from 8 previous repos
- No design insight, just FFI boilerplate

### Learning 2: Same C API (9th Confirmation) ‚≠ê

**Parser initialization:**
```c
TSParser *parser = ts_parser_new();
ts_parser_set_language(parser, tree_sitter_c_sharp());
```

**Why this doesn't matter:**
- Identical to Repos 1-8
- No new information
- 9th confirmation of same pattern
- We already have this working knowledge

### Learning 3: Auto-Generated Bindings Add No Value (Critical Meta-Lesson) ‚≠ê‚≠ê‚≠ê

**Pattern recognized:**

| Repo Type | Example | Value |
|-----------|---------|-------|
| **Auto-generated bindings (no examples)** | zig-tree-sitter (Repo 6), semgrep-c-sharp (Repo 9) | ‚ùå ZERO |
| **Hand-written with examples** | ltreesitter (Repo 5), tree-sitter CLI (Repo 3) | ‚úÖ HIGH |
| **Production code** | knut (Repo 7), c-language-server (Repo 4) | ‚úÖ HIGH |

**Key insight:** Auto-generated code teaches nothing about:
- How to USE tree-sitter effectively
- Design patterns and trade-offs
- Real-world usage examples
- Algorithm choices

**For future research:** Skip repos where all code is auto-generated

### Learning 4: No Highlighting Usage (Expected)

**What's missing:**
- ‚ùå No highlight queries
- ‚ùå No ANSI output code
- ‚ùå No theme system
- ‚ùå No decoration table or coloring algorithm
- ‚ùå No usage examples at all

**Why:** This is a parser wrapper for Semgrep's pattern matching, not a syntax highlighter

**Result:** Adds nothing to our highlighting knowledge

---

## P0 Questions: 9th Confirmation (No New Info)

### Q1: How to initialize parser? ‚úÖ (9th time)

**OCaml FFI wrapper:**
```c
TSParser *parser = ts_parser_new();
ts_parser_set_language(parser, tree_sitter_c_sharp());
```

**Same pattern as all previous repos.** No new information.

### Q2: How to parse code? ‚úÖ (9th time)

**OCaml wrapper calls:**
```ocaml
let parse_source_string ?src_file contents =
  let ts_parser = create_parser () in
  Tree_sitter_parsing.parse_source_string ?src_file ts_parser contents
```

**Underneath:** Same `ts_parser_parse_string()` we've seen 8 times. No new information.

### Q3: How to walk syntax tree? ‚úÖ (9th time - but not shown)

**This repo doesn't show tree walking** - It converts the tree-sitter CST into OCaml types immediately after parsing. The tree walking happens in the auto-generated code.

**For highlighting:** Still use queries (Repos 2-5, 7-8 approach)

### Q4: How to map node types ‚Üí colors? ‚ö†Ô∏è (N/A)

**Not applicable** - This repo doesn't do syntax highlighting at all.

**For highlighting:** Use query captures + theme lookup (Repos 3, 5 approach)

### Q5: How to output ANSI codes? ‚ö†Ô∏è (N/A)

**Not applicable** - This repo doesn't output colored text.

**For highlighting:** Use decoration table + ANSI codes (Repo 5 approach)

---

## Comparison to Previous Repos

### Repo 6 (zig-tree-sitter) vs Repo 9 (semgrep-c-sharp)

**Similarities:**
- Both are language bindings
- Both are auto-generated (Zig FFI, OCaml FFI)
- Both have ZERO usage examples
- Both add no value to our project
- Both confirm same C API (already known)

**Differences:**
- Zig bindings: Manual type declarations
- OCaml bindings: Custom GC integration

**Conclusion:** Same lesson twice - **binding repos without examples are useless**

### What Repos 5 (ltreesitter) Had That This Lacks

**ltreesitter (HIGH VALUE):**
- ‚úÖ `examples/c-highlight.lua` - Complete working highlighter
- ‚úÖ Decoration table algorithm
- ‚úÖ Real usage patterns
- ‚úÖ Hand-written design decisions

**semgrep-c-sharp (NO VALUE):**
- ‚ùå No examples
- ‚ùå No algorithms
- ‚ùå No usage patterns
- ‚ùå All auto-generated

**The difference:** One file (`c-highlight.lua`) is worth more than 1.5 million lines of auto-generated code.

---

## Key Insights

### Insight 1: Auto-Generation Hides Design ‚≠ê‚≠ê‚≠ê

**What auto-generation obscures:**
- Why certain patterns were chosen
- How to handle edge cases
- Performance considerations
- API design trade-offs

**What we need:** Hand-written code with decisions visible

### Insight 2: Examples > Bindings ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê

**Proven pattern:**

| Approach | Repos | Value for Learning |
|----------|-------|-------------------|
| **Bindings + Examples** | ltreesitter (Repo 5) | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê Perfect |
| **Production Code** | knut (Repo 7), c-language-server (Repo 4) | ‚≠ê‚≠ê‚≠ê‚≠ê High |
| **Official Tools** | tree-sitter CLI (Repo 3) | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê Perfect |
| **Bindings Alone** | zig-tree-sitter (Repo 6), semgrep-c-sharp (Repo 9) | ‚ùå Zero |

**Lesson confirmed (twice now):** Bindings without examples teach nothing

### Insight 3: Confirmation of Known Patterns ‚≠ê

**9th confirmation of:**
- `ts_parser_new()` + `ts_parser_set_language()`
- `extern "C" TSLanguage *tree_sitter_LANG()`
- Same C API across all languages

**Value:** Zero - We knew this after Repo 1

### Insight 4: Research Efficiency ‚≠ê‚≠ê

**Time wasted on binding repos:**
- Repo 6 (zig-tree-sitter): 45 minutes
- Repo 9 (semgrep-c-sharp): ~60 minutes
- **Total:** 105 minutes learning nothing new

**How to avoid:**
- Check for "auto-generated" in README
- Check for examples/ directory before deep study
- Skip repos with only bindings

---

## Value Assessment

### What This Repo Provides

‚úÖ **9th confirmation of C API** (redundant)  
‚úÖ **OCaml FFI pattern** (not relevant to C++)  
‚úÖ **Proof that parser.c can be compiled** (already knew from Repo 4)

### What This Repo Does NOT Provide

‚ùå **No highlighting algorithm**  
‚ùå **No query usage examples**  
‚ùå **No ANSI output code**  
‚ùå **No design patterns**  
‚ùå **No usage examples at all**  
‚ùå **No new information** (9th time seeing same patterns)

### Overall Value: 1/10 ‚≠ê

**Why so low:**
- Confirms known patterns (9th time)
- No examples or algorithms
- Auto-generated (no design decisions)
- OCaml-specific (we use C++)
- Adds ZERO to our knowledge base

**Why 1 point instead of 0:**
- Meta-lesson: Confirms binding repos are useless (valuable to know pattern)
- Shows another language's FFI approach (minor curiosity value)

---

## Recommendations

### For This Project

**‚ùå DO NOT use this repo as reference** - It provides nothing useful for our C++ syntax highlighter.

**‚úÖ Continue using Repos 5, 7, 4 as references:**
- Repo 5 (ltreesitter): THE algorithm (decoration table)
- Repo 7 (knut): THE architecture (CMake + C++)
- Repo 4 (c-language-server): Compile-time linking pattern

### For Future Research

**üö´ AVOID repos with these characteristics:**
1. "Generated by" comments everywhere
2. No examples/ directory
3. Just language bindings
4. No hand-written usage code
5. README says "auto-generated"

**‚úÖ PREFER repos with:**
1. examples/ directory with runnable code
2. Hand-written usage patterns
3. Production code with design decisions
4. Documentation explaining choices
5. Tests showing real usage

### Meta-Lesson

**This is the SECOND binding repo that added no value** (after Repo 6: zig-tree-sitter)

**Pattern recognition:**
- Auto-generated bindings = learning nothing
- Examples matter more than bindings
- Production code > generated code
- Design decisions > API wrappers

**For AI continuity:** If you see a repo with all auto-generated code, **skip detailed study**. Just confirm it's auto-generated and move on. No value in studying 1.5 million lines of generated code.

---

## Session Meta-Analysis

**Time invested:** ~60 minutes (exploration + documentation)  
**Value added:** 1% (meta-lesson confirmation only)  
**Lesson learned:** Auto-generated repos should be identified and skipped quickly  
**Confirmation:** Research procrastination continues (Repo 9 after 8 complete repos)

**Key realization:**
> We're now 9 repos deep. We have the algorithm (Repo 5), the architecture (Repo 7), and all P0 questions answered 9 times. Studying more repos (especially auto-generated ones) is pure procrastination.

**The pattern:**
- Repo 4-5: Found everything needed (algorithm + architecture)
- Repo 6: Binding repo, no value
- Repo 7: Architecture (but was already studied earlier)
- Repo 8: Validation that queries > manual
- Repo 9: Another binding repo, no value

**Conclusion:** Should have stopped after Repo 5 (or at latest, Repo 7)

---

## Updated Statistics

**Repos studied:** 9 of 29

1. ‚úÖ tree-sitter-issue-2012 (C) - Basic patterns ‚≠ê‚≠ê‚≠ê
2. ‚úÖ doxide (C++) - Query-based traversal ‚≠ê‚≠ê‚≠ê‚≠ê
3. ‚úÖ tree-sitter CLI (Rust) - Official highlighter ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê
4. ‚úÖ c-language-server (C++) - Compile-time linking ‚≠ê‚≠ê‚≠ê‚≠ê
5. ‚úÖ **ltreesitter (Lua/C) - THE ALGORITHM!** ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê
6. ‚ö†Ô∏è zig-tree-sitter (Zig) - Auto-generated bindings, no value ‚ùå
7. ‚úÖ **knut (C++/Qt) - THE ARCHITECTURE!** ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê
8. ‚úÖ GTKCssLanguageServer (Vala) - Validates queries > manual ‚≠ê‚≠ê‚≠ê
9. ‚ö†Ô∏è **semgrep-c-sharp (OCaml) - Auto-generated bindings, no value** ‚ùå

**Optimal stopping point:** After Repo 5 (or at latest Repo 8)  
**Study efficiency:** 77.8% (7 valuable repos / 9 total)  
**Wasted time:** 2 repos (Repos 6, 9) = ~105 minutes

---

## Final Verdict

### Should More Repos Be Studied?

**‚ùå ABSOLUTELY NOT**

**Why:**
1. All P0 questions answered (9 times)
2. Perfect algorithm found (ltreesitter - Repo 5)
3. Perfect architecture found (knut - Repo 7)
4. Query approach validated (Repos 2-5, 7-8)
5. Two binding repos wasted time (Repos 6, 9)
6. No knowledge gaps remain
7. Every additional repo = procrastination

**If tempted to study more:**

Ask yourself:
- What specific question remains unanswered? **(None)**
- What knowledge gap exists? **(None)**
- What could another repo teach us? **(Nothing - proven 9 times)**
- Do we have the algorithm? **(YES - ltreesitter)**
- Do we have the architecture? **(YES - knut)**
- Have we wasted enough time? **(YES - 2 useless repos already)**

**Answer:** Stop studying. Build prototype. NOW.

---

## What To Do Next

**üöÄ BUILD THE PROTOTYPE üöÄ**

This is not optional. This is THE ONLY correct next step.

**Why:**
- We have THE algorithm (decoration table - Repo 5)
- We have THE architecture (CMake + C++ - Repo 7)
- We have all P0 answers (9 confirmations)
- We have working examples (c-highlight.lua)
- Further study adds ZERO value (proven twice: Repos 6, 9)

**How:**
1. Re-read `external/ltreesitter/examples/c-highlight.lua`
2. Re-read `docs/study-ltreesitter.md`
3. Follow the implementation plan in RESUME-HERE.md
4. Translate decoration table algorithm to C++
5. Test with simple C++ code fence

**When:** NOW. Not after studying Repo 10. Not after "just one more." **NOW.**

---

## Code Snippets (Not Useful)

### OCaml FFI Wrapper (Complete)

```c
// lib/bindings.c - The only relevant file (51 lines total)

#include <string.h>
#include <tree_sitter/api.h>
#include <caml/alloc.h>
#include <caml/bigarray.h>
#include <caml/callback.h>
#include <caml/custom.h>
#include <caml/memory.h>
#include <caml/mlvalues.h>
#include <caml/threads.h>

// Standard pattern
TSLanguage *tree_sitter_c_sharp();

typedef struct _parser {
  TSParser *parser;
} parser_W;

static void finalize_parser(value v) {
  parser_W *p = (parser_W *)Data_custom_val(v);
  ts_parser_delete(p->parser);  // Cleanup
}

static struct custom_operations parser_custom_ops = {
  .identifier = "parser handling",
  .finalize = finalize_parser,
  .compare = custom_compare_default,
  .hash = custom_hash_default,
  .serialize = custom_serialize_default,
  .deserialize = custom_deserialize_default
};

CAMLprim value octs_create_parser_c_sharp(value unit) {
  CAMLparam0();
  CAMLlocal1(v);

  parser_W parserWrapper;
  TSParser *parser = ts_parser_new();           // Standard
  parserWrapper.parser = parser;

  v = caml_alloc_custom(&parser_custom_ops, sizeof(parser_W), 0, 1);
  memcpy(Data_custom_val(v), &parserWrapper, sizeof(parser_W));
  ts_parser_set_language(parser, tree_sitter_c_sharp());  // Standard
  CAMLreturn(v);
}
```

**Usefulness:** None - OCaml-specific FFI boilerplate

### Parse Wrapper (OCaml)

```ocaml
(* lib/Parse.ml - Entry functions *)

external create_parser :
  unit -> Tree_sitter_API.ts_parser = "octs_create_parser_c_sharp"

let parse_source_string ?src_file contents =
  let ts_parser = create_parser () in
  Tree_sitter_parsing.parse_source_string ?src_file ts_parser contents

let parse_source_file src_file =
  let ts_parser = create_parser () in
  Tree_sitter_parsing.parse_source_file ts_parser src_file
```

**Usefulness:** None - Auto-generated wrapper code

### Main Entry Point (OCaml)

```ocaml
(* bin/Main.ml - Complete file *)

open Tree_sitter_c_sharp

let () =
  Tree_sitter_run.Main.run
    ~lang:"c_sharp"
    ~parse_source_file:Parse.parse_source_file
    ~parse_input_tree:Parse.parse_input_tree
    ~dump_tree:Boilerplate.dump_tree
    ~dump_extras:Boilerplate.dump_extras
```

**Usefulness:** None - Generic test harness

---

## Conclusion

**Repo 9 (semgrep-c-sharp) teaches us nothing new.**

It's the second auto-generated binding repo (after Repo 6) that:
- Confirms known C API patterns (9th time)
- Provides no usage examples
- Adds no design insights
- Wastes research time

**Key lesson:** Auto-generated binding repos should be **immediately skipped** in future research.

**For our project:** Ignore this repo completely. Use Repos 5 (algorithm) and 7 (architecture) as references.

**Next step:** STOP STUDYING. BUILD PROTOTYPE. Use the decoration table from ltreesitter and CMake patterns from knut.

**Do NOT study Repo 10.**
