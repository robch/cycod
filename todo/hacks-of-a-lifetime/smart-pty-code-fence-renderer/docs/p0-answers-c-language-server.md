# P0 Questions - Answers from c-language-server Study

**Repo:** dgawlik/c-language-server  
**Date:** 2025-12-15 (Session 3, Repo 4)  
**Quick Reference:** Essential findings for prototype implementation  

---

## âœ… Q1: How to initialize parser?

**Answer:** CONFIRMED - Same pattern as repos 1-3.

```cpp
// Declare the grammar function (defined in parser.c)
extern "C" TSLanguage *tree_sitter_c();

// Create parser and set language
TSParser *parser = ts_parser_new();
ts_parser_set_language(parser, tree_sitter_c());
```

**From:** `lib/src/stack-graph-engine.cpp` lines 47-50

**Key insight:** Grammar function comes from compiling `parser.c` directly into executable!

---

## âœ… Q2: How to parse code?

**Answer:** CONFIRMED - Standard pattern with lifecycle.

```cpp
// Parse string to tree
TSTree *tree = ts_parser_parse_string(
    parser,
    NULL,              // old_tree for incremental parsing
    source_code,
    strlen(source_code));

// Get root node (value type, not pointer)
TSNode root_node = ts_tree_root_node(tree);

// Use tree...

// Cleanup
ts_tree_delete(tree);
ts_parser_delete(parser);  // Don't forget this!
```

**From:** `lib/src/stack-graph-engine.cpp` lines 52-76

**Important:** Always delete tree AND parser to avoid memory leaks!

---

## âœ… Q3: How to walk syntax tree?

**Answer:** NEW APPROACH - Manual traversal with field access.

### Option A: Manual Recursive Traversal

```cpp
void walkTree(TSNode node, const char* source_code) {
    // Skip error nodes
    if (strcmp(ts_node_type(node), "ERROR") == 0) {
        return;
    }
    
    // Handle specific node types
    if (strcmp(ts_node_type(node), "function_definition") == 0) {
        // Use field names for structured access
        TSNode declarator = ts_node_child_by_field_name(
            node, "declarator", strlen("declarator"));
        TSNode body = ts_node_child_by_field_name(
            node, "body", strlen("body"));
        
        // Process specific parts...
    }
    
    // Recurse to children
    for (uint32_t i = 0; i < ts_node_child_count(node); i++) {
        walkTree(ts_node_child(node, i), source_code);
    }
}
```

**From:** `lib/src/stack-graph-tree.cpp` lines 178-392

### Option B: Query-Based (from previous repos)

Still prefer queries for highlighting - this repo just shows manual traversal is viable.

**Key discovery:** `ts_node_child_by_field_name()` is very powerful!
- Cleaner than indexed access
- Self-documenting
- Field names defined in grammar

---

## âŒ Q4: How to map node types â†’ colors?

**Not applicable** - This repo doesn't do syntax highlighting.

Already fully answered by **Repo 3** (tree-sitter CLI) - see `docs/study-doxide-and-tree-sitter-cli.md`.

---

## âŒ Q5: How to output ANSI codes?

**Not applicable** - No terminal output in this tool.

Already fully answered by **Repo 3** (tree-sitter CLI) - see `docs/study-doxide-and-tree-sitter-cli.md`.

---

## ðŸŽ¯ CRITICAL DISCOVERY: Compile-Time Grammar Linking

**This is the biggest finding from this repo!**

### How It Works

**From `CMakeLists.txt` line 25:**
```cmake
add_executable(c_language_server 
    app/main.cpp 
    deps/tree-sitter-c/parser.c    # â† Compile grammar directly!
    lib/src/stack-graph-tree.cpp 
    lib/src/stack-graph-engine.cpp)
```

**What this means:**
1. Download `parser.c` from grammar repo (e.g., tree-sitter-cpp)
2. Add it to your CMakeLists.txt as a source file
3. Declare the function: `extern "C" TSLanguage *tree_sitter_cpp();`
4. Call it: `ts_parser_set_language(parser, tree_sitter_cpp());`

**No dynamic loading needed!** Much simpler than .so/.dll approach.

### The parser.c File

- Generated by Tree-sitter CLI from `grammar.js`
- Self-contained (~40K-75K lines of C code)
- Exports one function returning `const TSLanguage*`
- Contains all parse tables, lexer, symbol names, etc.

**Example:** `deps/tree-sitter-c/parser.c` line 75605:
```c
extern const TSLanguage *tree_sitter_c(void) {
    static const TSLanguage language = {
        .version = LANGUAGE_VERSION,
        .symbol_count = SYMBOL_COUNT,
        .parse_table = &ts_parse_table[0][0],
        // ... all the grammar data ...
    };
    return &language;
}
```

### For Our Prototype

To support C++:
1. Clone https://github.com/tree-sitter/tree-sitter-cpp
2. Copy `src/parser.c` to our project
3. Add to CMakeLists.txt: `add_executable(highlighter main.cpp parser.c)`
4. Declare: `extern "C" TSLanguage *tree_sitter_cpp();`
5. Use: `ts_parser_set_language(parser, tree_sitter_cpp());`

**Done!** No complex loading logic needed.

---

## ðŸŽ¨ C++ Wrapper Pattern

**Very useful for making Tree-sitter API ergonomic in C++.**

### The Wrapper

**From `lib/src/stack-graph-tree.cpp` lines 28-88:**

```cpp
class TSNodeWrapper {
    TSNode tsnode;  // Store the value type
    
public:
    TSNodeWrapper(TSNode n) : tsnode(n) {}
    
    const char* type() const {
        return ts_node_type(tsnode);
    }
    
    TSNodeWrapper childByFieldName(const char* name) const {
        auto node = ts_node_child_by_field_name(
            tsnode, name, strlen(name));
        return TSNodeWrapper(node);
    }
    
    uint32_t child_count() const {
        return ts_node_child_count(tsnode);
    }
    
    TSNodeWrapper child(uint32_t i) const {
        return TSNodeWrapper(ts_node_child(tsnode, i));
    }
    
    std::string text(const char* source) const {
        uint32_t start = ts_node_start_byte(tsnode);
        uint32_t end = ts_node_end_byte(tsnode);
        return std::string(source + start, end - start);
    }
    
    // Allow using wrapper where TSNode expected
    operator TSNode() const { return tsnode; }
};
```

### Benefits

**Before (C API):**
```cpp
const char* t = ts_node_type(node);
TSNode child = ts_node_child_by_field_name(node, "body", strlen("body"));
uint32_t start = ts_node_start_byte(node);
```

**After (C++ wrapper):**
```cpp
auto t = node.type();
auto child = node.childByFieldName("body");
auto start = node.startByte();
```

Much cleaner! **We should use this pattern in our prototype.**

---

## ðŸ“Š Performance Data

**From README:**
- **Small files:** < 1ms parse time
- **Medium projects:** 50 files/second
- **Large codebases:** Linux kernel (60K+ files) in 3-4 minutes

**For our use case:**
- Code fences typically 10-100 lines
- Parse time: < 1ms per fence
- No caching needed initially
- Parse on-demand is perfectly viable

**Verdict:** Don't worry about performance upfront!

---

## ðŸ”§ What to Use in Prototype

### âœ… Adopt from This Repo

1. **Compile-time grammar linking**
   - Add parser.c to CMakeLists.txt
   - Much simpler than dynamic loading

2. **C++ wrapper class**
   - Makes API cleaner and more idiomatic
   - Wrap TSNode in a class with methods

3. **Field-based navigation**
   - Use `ts_node_child_by_field_name()` when possible
   - Cleaner than indexed access

4. **Error handling**
   - Check for `"ERROR"` node type and skip
   - Simple and effective

5. **RAII for parser lifecycle**
   - Wrap TSParser* in class with constructor/destructor
   - Automatic cleanup

### âŒ Don't Adopt

1. **Stack graph building** - Too complex for highlighting
2. **Cross-file linking** - We process one fence at a time
3. **Manual tree traversal for highlighting** - Queries are better
4. **Regex dependencies** - Tree-sitter handles parsing

---

## ðŸš€ Ready for Prototype?

**YES!** After 4 repos studied, we have complete understanding:

| Question | Status |
|----------|--------|
| Q1: Parser init | âœ… CONFIRMED (4 repos) |
| Q2: Parsing code | âœ… CONFIRMED (4 repos) |
| Q3: Tree walking | âœ… TWO APPROACHES (queries + manual) |
| Q4: Node â†’ color | âœ… FROM REPO 3 (theme system) |
| Q5: ANSI output | âœ… FROM REPO 3 (event-based) |
| Grammar loading | âœ… FROM REPO 4 (compile-time) |
| C++ integration | âœ… FROM REPO 4 (wrapper pattern) |
| Performance | âœ… PROVEN (production use) |

**No unknowns left!** Time to build.

---

## ðŸ“ Quick Start Code for Prototype

```cpp
// 1. Declare grammar function (from parser.c)
extern "C" TSLanguage *tree_sitter_cpp();

// 2. Create and initialize parser
TSParser *parser = ts_parser_new();
ts_parser_set_language(parser, tree_sitter_cpp());

// 3. Parse code
const char *code = "int main() { return 0; }";
TSTree *tree = ts_parser_parse_string(parser, NULL, code, strlen(code));

// 4. Get root node
TSNode root = ts_tree_root_node(tree);

// 5. Run highlight query (TODO)
// 6. Output ANSI colored text (TODO)

// 7. Cleanup
ts_tree_delete(tree);
ts_parser_delete(parser);
```

Add:
- C++ wrapper class for ergonomics
- Query loading and execution (from Repo 2)
- ANSI output (from Repo 3)
- Theme lookup (from Repo 3)

**That's it!**

---

**Study Reference:** See `docs/study-c-language-server.md` for full details.
